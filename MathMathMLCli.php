<?php

/**
 * Created by PhpStorm.
 * User: Moritz
 * Date: 15.08.2017
 * Time: 09:33
 */
class MathMathMLCli extends MathMathML {

	/**
	 * @param $tags
	 * @return bool
	 * @throws MWException
	 */
	public static function batchEvaluate( &$tags ) {
		$req = [];
		foreach ( $tags as $key => $tag ) {
			/** @var MathMathMLCli $renderer */
			$renderer = $tag[0];
			// checking if the rendering is in the database is no security issue since only the md5
			// hash of the user input string will be sent to the database
			if ( !$renderer->isInDatabase() ) {
				$req[] = $renderer->getMathoidCliQuery();
			}
		}
		if ( count( $req ) === 0 ) {
			return true;
		}
		$exitCode = 1;
		$res = self::evaluateWithCli( $req, $exitCode );
		foreach ( $tags as $key => $tag ) {
			/** @var MathMathMLCli $renderer */
			$renderer = $tag[0];
			if ( !$renderer->isInDatabase() ) {
				$renderer->initializeFromCliResponse( $res );
			}
		}

		return true;
	}

	/**
	 * @param Object $res
	 * @return bool
	 */
	private function initializeFromCliResponse( $res ) {
		global $wgMathoidCli;
		if ( !property_exists( $res, $this->getMd5() ) ) {
			$this->lastError = "not rendered" . var_export( get_object_vars( $res ), false );

			// TODO error handling
			return false;
		}
		$response = $res->{$this->getMd5()};
		if ( !$response->success ) {
			$this->lastError =
				"not rendered succ" . var_export( get_object_vars( $response ), true );

			// TODO error handling
			return false;
		}
		$this->texSecure = true;
		$this->tex = $response->sanetex;
		// The host name is only relevant for the debugging. So using file:// to indicate that the
		// cli interface seems to be OK.
		$this->processJsonResult( $response, 'file://' . $wgMathoidCli );
		$this->mathStyle = $response->mathoidStyle;
		$this->png = implode( array_map( "chr", $response->png->data ) );
		$this->changed = true;
	}

	/**
	 * @return array
	 */
	public function getMathoidCliQuery() {
		return [
			'query' => [
				'q' => $this->getTex(),
				'type' => $this->getInputType(),
				'hash' => $this->getMd5(),
			],
		];
	}

	/**
	 * @param $req
	 * @param $exitCode
	 * @return mixed
	 * @throws MWException
	 */
	public static function evaluateWithCli( $req, &$exitCode = null ) {
		global $wgMathoidCli;
		$json_req = json_encode( $req );
		$renderings = self::wfShellExecMath( $wgMathoidCli, $exitCode, [], [], [], $json_req );
		if ( $exitCode != 0 ) {
			throw new MWException( "Mathoid cli '$wgMathoidCli' is not executable." );
		}
		$res = json_decode( $renderings );
		if ( !$res ) {
			throw new MWException( "Mathoid cli response is no valid JSON file." );
		}

		return $res;
	}

	public function render( $forceReRendering = false ) {
		if ( $this->getLastError() ) {
			return false;
		}

		return true;
	}

	protected function doCheck() {
		// avoid that restbase is called if check is set to always
		return $this->texSecure;
	}

	protected function initializeFromDatabaseRow( $rpage ) {
		if ( !empty( $rpage->math_svg ) ) {
			$this->png = $rpage->math_png;
		}
		parent::initializeFromDatabaseRow( $rpage ); // TODO: Change the autogenerated stub
	}

	protected function dbOutArray() {
		$out = parent::dbOutArray();
		$out['math_png'] = $this->png;

		return $out;
	}

	protected function dbInArray() {
		$out = parent::dbInArray();
		$out[] = 'math_png';

		return $out;
	}

	public function getPng() {
		if ( !$this->png ) {
			$this->initializeFromCliResponse( self::evaluateWithCli( [
				$this->getMathoidCliQuery(),
			] ) );

		}

		return parent::getPng();
	}

	/**
	 * This is a workaround for the fact that wfShellExec does not support outputs to stdout. This
	 * function is equivalent to
	 * <code>
	 * $f = TempFSFile::factory( 'mathoid', 'json', wfTempDir() );
	 * $f->autocollect();
	 * $fhandle = fopen( $f->getPath(), 'w' );
	 * if ( $fhandle ) {
	 *   fwrite( $fhandle, $stdout );
	 *   fclose( $fhandle );
	 * }
	 * $contents =
	 *   wfShellExec( '/tmp/mathoid/cli.js -c /tmp/mathoid/config.dev.yaml ' . $f->getPath(),
	 *     $retval );
	 * Execute a shell command, with time and memory limits mirrored from the PHP
	 * configuration if supported.
	 *
	 * @param string|string[] $cmd If string, a properly shell-escaped command line,
	 *   or an array of unescaped arguments, in which case each value will be escaped
	 *   Example:   [ 'convert', '-font', 'font name' ] would produce "'convert' '-font' 'font name'"
	 * @param null|mixed &$retval Optional, will receive the program's exit code.
	 *   (non-zero is usually failure). If there is an error from
	 *   read, select, or proc_open(), this will be set to -1.
	 * @param array $environ Optional environment variables which should be
	 *   added to the executed command environment.
	 * @param array $limits Optional array with limits(filesize, memory, time, walltime)
	 *   this overwrites the global wgMaxShell* limits.
	 * @param array $options Array of options:
	 *   - duplicateStderr: Set this to true to duplicate stderr to stdout,
	 *     including errors from limit.sh
	 *   - profileMethod: By default this function will profile based on the calling
	 *     method. Set this to a string for an alternative method to profile from
	 *
	 * @param string $stdout String to send to the standard output or false
	 * @return string Collected stdout as a string
	 * @throws Exception
	 */
	private static function wfShellExecMath(
		$cmd, &$retval = null, $environ = [], $limits = [], $options = [], $stdout = ''
	) {
		global $IP, $wgMaxShellMemory, $wgMaxShellFileSize, $wgMaxShellTime, $wgMaxShellWallClockTime, $wgShellCgroup;

		$disabled = wfShellExecDisabled();
		if ( $disabled ) {
			$retval = 1;

			return 'Unable to run external programs, proc_open() is disabled.';
		}

		$includeStderr = isset( $options['duplicateStderr'] ) && $options['duplicateStderr'];
		$profileMethod =
			isset( $options['profileMethod'] ) ? $options['profileMethod'] : wfGetCaller();

		wfInitShellLocale();

		$envcmd = '';
		foreach ( $environ as $k => $v ) {
			if ( wfIsWindows() ) {
				/* Surrounding a set in quotes (method used by wfEscapeShellArg) makes the quotes themselves
				 * appear in the environment variable, so we must use carat escaping as documented in
				 * https://technet.microsoft.com/en-us/library/cc723564.aspx
				 * Note however that the quote isn't listed there, but is needed, and the parentheses
				 * are listed there but doesn't appear to need it.
				 */
				$envcmd .= "set $k=" . preg_replace( '/([&|()<>^"])/', '^\\1', $v ) . '&& ';
			} else {
				/* Assume this is a POSIX shell, thus required to accept variable assignments before the command
				 * http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_01
				 */
				$envcmd .= "$k=" . escapeshellarg( $v ) . ' ';
			}
		}
		if ( is_array( $cmd ) ) {
			$cmd = wfEscapeShellArg( $cmd );
		}

		$cmd = $envcmd . $cmd;

		$useLogPipe = false;
		if ( is_executable( '/bin/bash' ) ) {
			$time = intval( isset( $limits['time'] ) ? $limits['time'] : $wgMaxShellTime );
			if ( isset( $limits['walltime'] ) ) {
				$wallTime = intval( $limits['walltime'] );
			} elseif ( isset( $limits['time'] ) ) {
				$wallTime = $time;
			} else {
				$wallTime = intval( $wgMaxShellWallClockTime );
			}
			$mem = intval( isset( $limits['memory'] ) ? $limits['memory'] : $wgMaxShellMemory );
			$filesize =
				intval( isset( $limits['filesize'] ) ? $limits['filesize'] : $wgMaxShellFileSize );

			if ( $time > 0 || $mem > 0 || $filesize > 0 || $wallTime > 0 ) {
				$cmd =
					'/bin/bash ' . escapeshellarg( "$IP/includes/limit.sh" ) . ' ' .
					escapeshellarg( $cmd ) . ' ' .
					escapeshellarg( "MW_INCLUDE_STDERR=" . ( $includeStderr ? '1' : '' ) . ';' .
									"MW_CPU_LIMIT=$time; " . 'MW_CGROUP=' .
									escapeshellarg( $wgShellCgroup ) . '; ' .
									"MW_MEM_LIMIT=$mem; " . "MW_FILE_SIZE_LIMIT=$filesize; " .
									"MW_WALL_CLOCK_LIMIT=$wallTime; " . "MW_USE_LOG_PIPE=yes" );
				$useLogPipe = true;
			} elseif ( $includeStderr ) {
				$cmd .= ' 2>&1';
			}
		} elseif ( $includeStderr ) {
			$cmd .= ' 2>&1';
		}
		wfDebug( "wfShellExec: $cmd\n" );

		// Don't try to execute commands that exceed Linux's MAX_ARG_STRLEN.
		// Other platforms may be more accomodating, but we don't want to be
		// accomodating, because very long commands probably include user
		// input. See T129506.
		if ( strlen( $cmd ) > SHELL_MAX_ARG_STRLEN ) {
			throw new Exception( __METHOD__ .
								 '(): total length of $cmd must not exceed SHELL_MAX_ARG_STRLEN' );
		}

		$desc = [
			// 0 => [ 'file', 'php://stdin', 'r' ],
			0 => [ 'pipe', 'r' ],
			1 => [ 'pipe', 'w' ],
			2 => [ 'file', 'php://stderr', 'w' ],
		];
		if ( $useLogPipe ) {
			$desc[3] = [ 'pipe', 'w' ];
		}
		$pipes = null;
		$scoped = Profiler::instance()->scopedProfileIn( __FUNCTION__ . '-' . $profileMethod );
		$proc = proc_open( $cmd, $desc, $pipes );
		if ( !$proc ) {
			wfDebugLog( 'exec', "proc_open() failed: $cmd" );
			$retval = - 1;

			return '';
		}
		$outBuffer = $logBuffer = '';
		$emptyArray = [];
		$status = false;
		$logMsg = false;
		if ( $stdout ) {
			fwrite( $pipes[0], $stdout );
			fclose( $pipes[0] );
		}

		/* According to the documentation, it is possible for stream_select()
		 * to fail due to EINTR. I haven't managed to induce this in testing
		 * despite sending various signals. If it did happen, the error
		 * message would take the form:
		 *
		 * stream_select(): unable to select [4]: Interrupted system call (max_fd=5)
		 *
		 * where [4] is the value of the macro EINTR and "Interrupted system
		 * call" is string which according to the Linux manual is "possibly"
		 * localised according to LC_MESSAGES.
		 */
		$eintr = defined( 'SOCKET_EINTR' ) ? SOCKET_EINTR : 4;
		$eintrMessage = "stream_select(): unable to select [$eintr]";

		$running = true;
		$timeout = null;
		$numReadyPipes = 0;

		while ( $running === true || $numReadyPipes !== 0 ) {
			if ( $running ) {
				$status = proc_get_status( $proc );
				// If the process has terminated, switch to nonblocking selects
				// for getting any data still waiting to be read.
				if ( !$status['running'] ) {
					$running = false;
					$timeout = 0;
				}
			}

			$readyPipes = array_slice( $pipes, 1, null, true );
			if ( sizeof( $readyPipes ) === 0 ) {
				$numReadyPipes = 0;
				continue;
			}

			// Clear last error
			// @codingStandardsIgnoreStart Generic.PHP.NoSilencedErrors.Discouraged
			@trigger_error( '' );
			$numReadyPipes = @stream_select( $readyPipes, $emptyArray, $emptyArray, $timeout );
			if ( $numReadyPipes === false ) {
				// @codingStandardsIgnoreEnd
				$error = error_get_last();
				if ( strncmp( $error['message'], $eintrMessage, strlen( $eintrMessage ) ) == 0 ) {
					continue;
				} else {
					trigger_error( $error['message'], E_USER_WARNING );
					$logMsg = $error['message'];
					break;
				}
			}
			foreach ( $readyPipes as $fd => $pipe ) {
				$block = fread( $pipe, 65536 );
				if ( $block === '' ) {
					// End of file
					fclose( $pipes[$fd] );
					unset( $pipes[$fd] );
					if ( !$pipes ) {
						break 2;
					}
				} elseif ( $block === false ) {
					// Read error
					$logMsg = "Error reading from pipe";
					break 2;
				} elseif ( $fd == 1 ) {
					// From stdout
					$outBuffer .= $block;
				} elseif ( $fd == 3 ) {
					// From log FD
					$logBuffer .= $block;
					if ( strpos( $block, "\n" ) !== false ) {
						$lines = explode( "\n", $logBuffer );
						$logBuffer = array_pop( $lines );
						foreach ( $lines as $line ) {
							wfDebugLog( 'exec', $line );
						}
					}
				}
			}
		}

		foreach ( $pipes as $pipe ) {
			if ( is_resource( $pipe ) ) {
				fclose( $pipe );
			}
		}

		// Use the status previously collected if possible, since proc_get_status()
		// just calls waitpid() which will not return anything useful the second time.
		if ( $running ) {
			$status = proc_get_status( $proc );
		}

		if ( $logMsg !== false ) {
			// Read/select error
			$retval = - 1;
			proc_close( $proc );
		} elseif ( $status['signaled'] ) {
			$logMsg = "Exited with signal {$status['termsig']}";
			$retval = 128 + $status['termsig'];
			proc_close( $proc );
		} else {
			if ( $status['running'] ) {
				$retval = proc_close( $proc );
			} else {
				$retval = $status['exitcode'];
				proc_close( $proc );
			}
			if ( $retval == 127 ) {
				$logMsg = "Possibly missing executable file";
			} elseif ( $retval >= 129 && $retval <= 192 ) {
				$logMsg = "Probably exited with signal " . ( $retval - 128 );
			}
		}

		if ( $logMsg !== false ) {
			wfDebugLog( 'exec', "$logMsg: $cmd" );
		}

		return $outBuffer;
	}
}
