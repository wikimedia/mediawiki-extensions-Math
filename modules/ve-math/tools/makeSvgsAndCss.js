#!/usr/bin/env node

/* jshint node: true */

( function () {
	var i, count, currentClassName, group, symbol, symbols, symbolObject,
		symbolsData, cssData, cssLines, backgroundPosition,
		cssRules = [], // Whole CSS rules
		cssClasses = {}, // Unique part of class name and whether baseline is shifted
		currentRule = [],
		symbolList = [], // Symbols whose CSS rules need to be added or adjusted
		symbolsFile = '../symbols.json',
		cssFile = '../ve.ui.MWMathSymbols.css',
		cssPrefix = '.ve-ui-mwMathSymbol-',
		fs = require( 'fs' ),
		http = require( 'http' ),
		querystring = require( 'querystring' ),
		SVGO = require( 'svgo' ),
		svgo = new SVGO( {
			plugins: [
				{ convertTransform: false }
			]
		} ),
		xml2js = require( 'xml2js' ),
		mathoidMaxConnections = 5,
		// If symbol.backgroundPosition is true, a background-position property will be added to the
		// CSS rule to shift the baseline of the SVG to be a certain proportion of the way up the
		// button.
		singleButtonHeight = 1.8, // Height of the single-height math dialog buttons in em
		baseline = 0.4; // Proportion of the way up the button the baseline should be

	symbolsData = fs.readFileSync( symbolsFile ).toString();
	try {
		cssData = fs.readFileSync( cssFile ).toString();
	} catch ( e ) {}

	function encodeURIComponentForCSS( str ) {
		return encodeURIComponent( str )
			.replace( /[!'\(\)\*]/g, function ( chr ) {
				return '%' + chr.charCodeAt( 0 ).toString( 16 );
			} );
	}

	function texToClass( tex ) {
		// Make the className, replacing any non-alphanumerics with their character code
		return tex.replace( /[^\w]/g, function ( c ) {
			return '_' + c.charCodeAt( 0 ) + '_';
		} );
	}

	function makeRequest( symbol ) {
		var body, className, offset, request,
			data = querystring.stringify( {
				q: symbol.tex
			} ),
			// API call to mathoid
			options = {
				host: 'mathoid.testme.wmflabs.org',
				port: '80',
				path: '/',
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
					'Content-Length': Buffer.byteLength( data )
				}
			};
		// Populate and make the API call
		request = http.request( options, function ( res ) {
			body = '';
			res.setEncoding( 'utf8' );

			res.on( 'data', function ( data ) {
				body += data;
			} );

			res.on( 'end', function () {
				className = texToClass( symbol.tex ),
					svg = JSON.parse( body ).svg;

				if ( !svg ) {
					console.log( symbol.tex + ' FAILED: ' + body );
					onEnd();
					return;
				}

				svgo.optimize( svg, function ( result ) {
					var cssRule = cssPrefix + className + ' {\n' +
						'\tbackground-image: url(data:image/svg+xml,' + encodeURIComponentForCSS( result.data ) + ');\n';
					if ( symbol.backgroundPosition ) {
						xml2js.parseString( svg, function( err, xml ) {
							var xmlObject = xml.svg.$,
								// Convert buttonHeight from em to ex, because SVG height is given in ex
								buttonHeight = symbol.largeLayout ? singleButtonHeight * 4 : singleButtonHeight * 2,
								// height and verticalAlign rely on the format of the SVG parameters
								height = parseFloat( xmlObject.height.slice( 0, -2 ) ),
								verticalAlign = parseFloat( xmlObject.style.match( /vertical-align\:\s*(.*)ex/ )[1] ),
								offset = 50 - 100 * ( baseline - 0.5 * ( 1 - height / buttonHeight - verticalAlign ) );
							cssRule += '\tbackground-position: 50% ' + offset + '%\n' +
								'}';
							cssRules.push( cssRule );
							console.log( symbol.tex + ' -> ' + className );
						} );
					} else {
						cssRule += '}';
						cssRules.push( cssRule );
						console.log( symbol.tex + ' -> ' + className );
					}
				} );
				onEnd();

			} );
		} );
		request.setTimeout( 10000 );
		request.write( data );
		request.end();
		runNext();
	}

	function onEnd() {
		count--;
		runNext();
	}

	function runNext() {
		if ( count < mathoidMaxConnections && symbolList.length ) {
			count++;
			makeRequest( symbolList.shift() );
		}
		if ( !symbolList.length && !count ) {
			cssRules.sort();
			fs.writeFileSync(
				cssFile,
				'/*!\n' +
				' * This file is GENERATED by tools/makeSvgsAndCss.js\n' +
				' * DO NOT EDIT\n' +
				' */\n' +
				'\n' +
				cssRules.join( '\n\n' ) +
				'\n'
			);
		}
	}

	if ( cssData ) {
		cssLines = cssData.split( '\n' );
		for ( i = 0; i < cssLines.length; i++ ) {
			if ( cssLines[ i ].indexOf( cssPrefix ) === 0 ) {
				currentClassName = cssLines[ i ].slice( cssPrefix.length, -2 );
				currentRule.push( cssLines[ i ] );
				cssClasses[ currentClassName ] = false; // Default to false
			} else if ( currentRule.length ) {
				currentRule.push( cssLines[ i ] );
				if ( cssLines[ i ].indexOf( '\tbackground-position' ) === 0 ) {
					cssClasses[ currentClassName ] = true;
				}
				if ( cssLines[ i ].indexOf( '}' ) === 0 ) {
					cssRules.push( currentRule.join( '\n' ) );
					currentRule.splice( 0, currentRule.length );
				}
			}
		}
	}

	symbolObject = JSON.parse( symbolsData );
	for ( group in symbolObject ) {
		symbols = symbolObject[ group ];
		for ( i = 0; i < symbols.length; i++ ) {
			symbol = symbols[ i ];
			if ( symbol.duplicate || symbol.notWorking ) {
				continue;
			}
			currentClassName = texToClass( symbol.tex );
			// If symbol is not in the old CSS file, or its backgroundPosition status has changed,
			// add it to symbolList. Check 'done' to make sure it hasn't already been added.
			if ( cssClasses[ currentClassName ] === undefined ||
				( cssClasses[ currentClassName ] !== 'done' &&
					cssClasses[ currentClassName ] === !symbol.backgroundPosition ) ) {
				symbolList.push( {
					tex: symbol.tex,
					backgroundPosition: symbol.backgroundPosition,
					largeLayout: symbol.largeLayout,
					reason: cssClasses[ currentClassName ] === undefined
				} );
			} else {
				// At the end of this loop, any CSS class names that are NOT marked 'done' will be
				// deleted from cssRules. cssRules will then only contain rules that will stay the
				// same.
				cssClasses[ currentClassName ] = 'done';
			}
		}
	}

	// Keep only classes that will stay the same. Remove classes that are being adjusted and classes
	// of symbols that have been deleted from the JSON.
	cssRules = cssRules.filter( function ( rule ) {
		currentClassName = rule.split( '\n' )[ 0 ].slice( cssPrefix.length, -2 );
		if ( cssClasses[ currentClassName ] === 'done' ) {
			return true;
		}
		console.log( 'Removing or adjusting: ' + currentClassName );
		return false;
	} );

	count = 0;
	runNext();

} )();
