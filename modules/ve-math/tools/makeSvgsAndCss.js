#!/usr/bin/env node

/* jshint node: true */

var i, count, group, symbols, symbolObject,
	symbolList = [],
	symbolsFile = '../symbols.json',
	cssFile = '../ve.ui.MWMathSymbols.css',
	fs = require( 'fs' ),
	http = require( 'http' ),
	querystring = require( 'querystring' ),
	SVGO = require( 'svgo' ),
	svgo = new SVGO( {
		plugins: [
			{ convertTransform: false }
		]
	} ),
	mathoidMaxConnections = 5;

fs.readFile( symbolsFile, function ( err, data ) {

	function encodeURIComponentForCSS( str ) {
		return encodeURIComponent( str )
			.replace( /[!'\(\)\*]/g, function ( chr ) {
				return '%' + chr.charCodeAt( 0 ).toString( 16 );
			} );
	}

	function makeRequest( symbol ) {
		var request,
			data = querystring.stringify( {
				q: symbol
			} ),
			// API call to mathoid
			options = {
				host: '192.168.37.177',
				port: '10044',
				path: '/',
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
					'Content-Length': Buffer.byteLength( data )
				}
			};

		// Populate and make the API call
		request = http.request( options, function ( res ) {
			var body = '';
			res.setEncoding( 'utf8' );

			res.on( 'data', function ( data ) {
				body += data;
			} );

			res.on( 'end', function () {
				var classname, svg;
				// Make the classname, replacing any non-alphanumerics with their character code
				classname = symbol.replace( /[^\w]/g, function ( c ) {
					return '_' + c.charCodeAt( 0 ) + '_';
				} );

				svg = JSON.parse( body ).svg;

				if ( !svg ) {
					console.log( symbol + ' FAILED: ' + body );
					onEnd();
					return;
				}

				svgo.optimize( svg, function ( result ) {
					// write to the css file
					fs.appendFileSync(
						cssFile,
						'\n.ve-ui-mwMathSymbol-' + classname + ' {\n' +
						'\tbackground-image: url(data:image/svg+xml,' + encodeURIComponentForCSS( result.data ) + ');\n' +
						'}\n'
					);
				} );
				console.log( symbol + ' -> ' + classname );
				onEnd();

			} );
		} );
		request.setTimeout( 10000 );
		request.write( data );
		request.end();
		runNext();
	}

	function onEnd() {
		count--;
		runNext();
	}

	function runNext() {
		if ( count < mathoidMaxConnections && symbolList.length ) {
			count++;
			makeRequest( symbolList.shift() );
		}
	}

	symbolObject = JSON.parse( data.toString() );
	for ( group in symbolObject ) {
		symbols = symbolObject[ group ];
		for ( i = 0; i < symbols.length; i++ ) {
			symbolList.push( symbols[ i ].tex );
		}
	}

	fs.writeFileSync( cssFile, '/*!\n * This file is GENERATED by tools/getSvgsAndCss.js\n * DO NOT EDIT\n */\n' );
	count = 0;
	runNext();

} );
